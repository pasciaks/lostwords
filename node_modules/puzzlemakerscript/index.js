/**
 * lostwords
 * 
 * Written By: Sheldon Pasciak, 2017 
 * 
 * */
var Copyright = "Sheldon Pasciak";

//TODO ABSTRACT FURTHER OUT, TAKE PUZZLE ITSELF OUT

var PuzzleMakerScript = {

    Owner: Copyright,

    thePuzzle: "",
    cols: 0,
    rows: 0,
    sx: 0,
    sy: 0,
    dx: 0,
    dy: 0,
    letterSet: "",
    emptyChar: ".",
    fillBlanksWith: ".",
    reuseLetters: true,
    diagonalsOnly: true,

    addWord: function(word, howManyTimes, dx, dy, howManyAttempts) {

        //defaults to add the word one time
        if (typeof howManyTimes == 'undefined') howManyTimes = 1;

        //defaults to use 999 attempts to hide the word randomly
        if (typeof howManyAttempts == 'undefined') howManyAttempts = 999;

        var wordsAdded = 0;

        var theWordsAdded = [];

        for (var j = 0; j < howManyAttempts; j++) {

            // TODO convert to random range
            this.sx = Math.floor(Math.random() * (this.cols - 1 - 0 + 1)) + 0; //randRange(0, PuzzleMakerScript.cols - 1);
            this.sy = Math.floor(Math.random() * (this.rows - 1 - 0 + 1)) + 0; //randRange(0, PuzzleMakerScript.rows - 1);

            this.dx = 1 - Math.floor(Math.random() * (2 - 1 - 0 + 1)) + 0;
            this.dy = 1 - Math.floor(Math.random() * (2 - 1 - 0 + 1)) + 0;
            
            // this.sx=this.randSX();
            // this.sy=this.randSY();
            
            // this.dx=this.pickDirection.dx;
            // this.dy=this.pickDirection.dy;

            //if direction uses directions if specified
            if (typeof dx != 'undefined') this.dx = dx;
            if (typeof dy != 'undefined') this.dy = dy;

            //if both directions are 0, default to word left to right
            if (this.dx == 0)
                if (this.dy == 0) this.dx = 1;

            if (wordsAdded < howManyTimes) {

                if (this.checkDirection(this.sx, this.sy, this.dx, this.dy, word, this.reuseLetters) == true) {

                    this.setDirection(this.sx, this.sy, this.dx, this.dy, word, function(data) {

                        //TODO use data points (theWordsAdded) to check for word collisions to make sure a path isn't the same as another. (can happen when reuse letters is enabled)
                        console.log("The Data Points:" + JSON.stringify(data));

                        wordsAdded++;

                        theWordsAdded.push(word);

                    });
                }
            }

        }

        return theWordsAdded;

    },

    /**
     * Creates and Does Something here...
     * 
     * @param   {int}           cols            column count
     * @param   {Function}      [callback]      Optional callback  
     * @returns {Object}        results         These are the results from the mysql library
     */
    checkDirection: function(sx, sy, dx, dy, word, reuseLetters) {

       // console.log("Reuse Letters:" + reuseLetters);

        for (var i = 0; i < word.length; i++) {
            if ((this.get(sx, sy) == this.emptyChar) || (this.get(sx, sy) == word[i])) {
                if (!reuseLetters)
                    if (this.get(sx, sy) == word[i]) return false; //option to only allow unique unshared letter hides
            }
            else {
                return false;
            }

            sx += dx;
            sy += dy;
            
            if (sx < 0) return false;
            if (sx > this.cols - 1) return false;
            if (sy < 0) return false;
            if (sy > this.rows - 1) return false;            
        }

        return true;
    },
    
    createLetterSet: function() {

        var commonLetters = ["E",
            "T",
            "A",
            "O",
            "I",
            "N",
            "S",
            "R",
            "H",
            "D",
            "L",
            "U",
            "C",
            "M",
            "F",
            "Y",
            "W",
            "G",
            "P",
            "B",
            "V",
            "K",
            "X",
            "Q",
            "J",
            "Z"
        ];

        var letterFrequency = [1202,
            910,
            812,
            768,
            731,
            695,
            628,
            602,
            592,
            432,
            398,
            288,
            271,
            261,
            230,
            211,
            209,
            203,
            182,
            149,
            111,
            69,
            17,
            11,
            10,
            7
        ];

        var letterChoices = "";

        this.letterSet = "";

        for (var i = 0; i < 26; i++) {
            for (var j = 0; j < letterFrequency[i]; j++) {
                letterChoices = letterChoices + commonLetters[i];
            }

        }

        this.letterSet = this.scramble(letterChoices);

        return letterChoices;
    },
    
    /**
     * todo: future hide directions, instead of straight line.
     * 
     * bends
     * 
     * right,left turns
     * 
     * lostwords world style boggle variation
     * 
     * */
    createPath: function(sx, sy, word) {
        
        console.log(this.cols + "," + this.rows);
        
        var randomDir = this.pickDirection()
        
        var thePath = [];

        if (this.get(sx, sy) == this.emptyChar) console.log('start ok');
        
        console.log("cols:"+ this.cols  );
        console.log("rows:"+ this.rows  );
        
        // CURRENT WAY AHEAD
        // CREATE ANOTHER BLANK PUZZLE, TRY TO MAKE RANDOM PATHS THAT FIT
        // THEN USE THESE PATHS TO TRY TO FIT CURRENT PUZZLE
        
        // TODO need to use a check direction scheme
        
        // TODO need a copy of puzzle (this.get  this.set  so we can modify a temp version to check new word add paths here in create path)
        // TODO the logic below doesn't get it done. yet
        
        // for (var i=0;i<word.length;i++) {
        //     if (this.get(sx,sy)!==this.emptyChar) {
        //         console.log('not empty ==>' + this.get(sx,sy) );
        //         if (this.reuseLetters) {
        //             if (this.get(sx,sy)==word[i]) {
        //                 //okay there's already the letter needed there and option is set to reuseLetters = true;
        //             } else {
        //                 return { 'result':false, 'thePath': null };
        //             }
        //         }
        //     }
            
        //     thePath.push( {'sx':sx,'sy':sy,'letter':word[i]} );
            
        //     randomDir = this.pickDirection();
        //     sx+=randomDir.dx;
        //     sy+=randomDir.dy;
            
        //     if (sx<0) return { 'result':false, 'thePath': null };
        //     if (sx>this.cols-1) return { 'result':false, 'thePath': null };
        //     if (sy<0) return { 'result':false, 'thePath': null };
        //     if (sy>this.rows-1) return { 'result':false, 'thePath': null };
            
        // }
        
        return { 'result':true, 'thePath': thePath };

    },
    
    fillBlanks: function(fillWith) {

        if (typeof fillWith == 'undefined') fillWith = this.letterSet;

        console.log('fillBlanks:' + fillWith);

        for (var r = 0; r < this.rows; r++) {
            for (var c = 0; c < this.cols; c++) {
                if (this.get(c, r) == this.emptyChar) this.set(c, r, fillWith.charAt(Math.floor(Math.random() * fillWith.length)));
            }
        }

        //TODO fillBlanks with an option ... instead of random chars from "CHTAJEKZOPBMQZ" , IT cycles through them. "THEWORDSINPUZZLE"


    },
    
    get: function(col, row) {
        return this.thePuzzle[(col + row * this.cols)];
    },
    
    init: function(cols, rows, callback) {
        
        // for (var i=0;i<999;i++){
        //     console.log(this.randRange(0,3));
        // }

        this.cols = cols;
        this.rows = rows;

        this.thePuzzle = "";

        for (var j = 0; j < rows; j++) {
            for (var i = 0; i < cols; i++) {
                this.thePuzzle += this.emptyChar;
            }
        }

        this.createLetterSet();

        if (typeof callback != 'undefined') callback(this.thePuzzle);
    },
    
    pickDirection: function() {
            
        var dx = 1-this.randRange(0,2);
        var dy = 1-this.randRange(0,2);
        
        if (dx==0) {if (dy==0) dx=1}
        
        return {'dx':dx,'dy':dy};
        
    },
    
    randSX: function() {
         return this.randRange(0,this.cols-1);
    },
    
    randSY: function() {
        return this.randRange(0,this.rows-1);
    },   
    
    randRange: function(min,max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    },
    
    scramble: function(str) {

        var scrambled = '',
            src = str.split(''),
            randomNum;

        while (src.length > 1) {
            randomNum = Math.floor(Math.random() * src.length);
            scrambled += src[randomNum];
            src.splice(randomNum, 1);
        }

        scrambled += src[0];
        return scrambled;
    },

    set: function(col, row, character) {
        var location = (col + row * this.cols);
        this.thePuzzle = this.thePuzzle.substr(0, location) + character + this.thePuzzle.substr(location + 1);
    },

    setDirection: function(sx, sy, dx, dy, word, cb) {

        var points = [];

        for (var i = 0; i < word.length; i++) {
            this.set(sx, sy, word[i]);
            points.push({
                'x': sx,
                'y': sy,
                'l': word[i]
            });
            sx += dx;
            sy += dy;
        }

        if (typeof cb != 'undefined') cb(points);
    },

    show: function() {

        var line = "";

        for (var r = 0; r < this.rows; r++) {
            for (var c = 0; c < this.cols; c++) {
                line += this.get(c, r) + " ";
            }
            console.log(line);
            line = "";
        }

        console.log(this.Owner);
    }

};

module.exports = PuzzleMakerScript;
